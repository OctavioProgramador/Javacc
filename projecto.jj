options {
	STATIC = false;
}

PARSER_BEGIN(lexico)
	import java.io.PrintStream;
	import java.util.ArrayList;
	class lexico {
		public static void main (String [] args)
		throws ParseException, TokenMgrError{
			lexico parser = new lexico( System.in);
			parser.Start(System.out); }
	}
PARSER_END(lexico)

SKIP : { "\t"| "\r" | "\r\n" | "\n" | " "}
/*Definiciones regulares*/
TOKEN : { < #WORD : ((["a"-"z"]|["A"-"Z"]))+ > } 
TOKEN : { < #SPECIAL : "_" | "@" | "." > }
/*Componentes lexicos*/	
TOKEN : { < Asignacion: "="> {System.out.println("Asignacion");}} //1
TOKEN : { < OperadorRelacional: "==" | "!="  | ">"  | "<"  | "=>" |  "<=" >  //2
	{System.out.println("OperadorRelacional ("+image+")");}} 
TOKEN : { < Parentesis: "(" | ")">{System.out.println("Parentesis ("+image+")");}} //3
TOKEN : { < Corchete: "["  | "]">{System.out.println("Corchete ("+image+")");}} //4
TOKEN : { < Comentario: "/*" | "*/" |  "//"> {System.out.println("Comentario ("+image+")");}} //5
TOKEN : { < OperadorAritmeticoUnario: "++" | "--" > {System.out.println("OperadorAritmeticoUnario ("+image+")");}} //6
TOKEN : { < OperadorAritmeticoBinario :  "+" | "-" | "*" | "/" | "*=" | "+=" | "-=" | "*=" | "/=" >  
	{System.out.println("OperadorAritmeticoBinario ("+image+")");}} //7
TOKEN : { < FuncionMatematica : "sqrt" | "abs"> {System.out.println("FuncionMatematica ("+image+")");}} //8
TOKEN : { < OperadoresLogicos : "&&" | "||" | "XOR" > 
	{System.out.println("OperadoresLogicos ("+image+")");}} //9
TOKEN : { < Llaves : "{" | "}" > {System.out.println("Llaves ("+image+")");}} //10
TOKEN : { < ReferenciasPunteros : "this" | "&" > {System.out.println("ReferenciasPunteros ("+image+")");}} //11
TOKEN : { < NUMBER : (["0"-"9"])+ >{System.out.println("Numero");}  }
TOKEN : { < Coma : "," > {System.out.println("Coma");}} //12
TOKEN : { < Rango : ":" > {System.out.println("Rango");}} //13
TOKEN : { < DirectivasDePreprocesador : "#include"|"#define"|"#endif" > 
	{System.out.println("DirectivasDePreprocesador ("+image+")");}} //14
TOKEN : { < SentenciaIF : "if"|"else"> {System.out.println("SentenciaIf("+image+")");}} //15
TOKEN : { < FuncionesPredefinidasFuncionales : "how"|"map"|"zip"|"filter"|"foldr"|"foldl"|"lenght"|"head"|"fst"|"snd"|"tail"|"id"|"show"|"iter"|"next"|"list"|"tuple"|"max"|"min"|"values"|"dict"|"sum"|"sorted"|"any"|"all">{System.out.println("FuncionPredefinida ("+image+")");}} //16 Dividir mejor esta parte
TOKEN : { < FuncionesPredefinidasIterativas : "count"|"range"|"cycle"|"repeat"|"chain"|"tee"|"islice"|"filterfalse"|"takewhile" > { System.out.println("FuncionesPredefinidasIterativas ("+image+")");}}
TOKEN: {<ReferenciaApuntador: "&" | "this">{System.out.println("ReferenciaApuntador");}} //16
TOKEN: {<TipoDeDato: "int" | "char" | "string" | "bool" | "decimal" | "void" | "long"| "double" | "data" | "function" | "float" | "byte" | "sbyte" | "short" | "ushort" | "int16" | "int64" | "ulong" | "uint" | "nint" > {System.out.println("TipoDeDato ("+image+")");}} //17
TOKEN: {<AccesoAElementos: "." | "->">{System.out.println("AccesoAElementos -> " + image);}} //18
TOKEN: {<FinDeLinea: ";">{System.out.println("FinDeLinea");} } //19
TOKEN: {<Comillas: "\""| "\'">{System.out.println("Comillas");}} //20
TOKEN : {<Return: "return">{System.out.println("return");}} //22
TOKEN : {<Of: "of">{System.out.println("OfExpresionCase");}} //23
TOKEN : {<Let: "let" >{System.out.println("in");}} //24
TOKEN : {<In: "in" >{System.out.println("let ");}}
TOKEN : {<ClasesPredefinidas: "BinaryTree"|"vector"|"Leaf"|"Branch" >{System.out.println("ClasesPredefinidas ("+image+")");}} //25
TOKEN : {<DeclaracionDeTipos: "newtype" > {System.out.println("DeclaracionDeTipos");}} //26
TOKEN : {<ExpresionWhere : "where" > {System.out.println("ExpresionWhere");}} //27
TOKEN : {<ExpresionDeConversion: "as" >{System.out.println("as");}} //30
TOKEN : {<InterrupcionDeProcesos: "continue" | "break" >{System.out.println("InterrupcionDeProcesos ("+image+")");}} //31
// TOKEN : {<ComponentesSentenciaCase: "switch"|"case"|"default" >{System.out.println("ComponentesSentenciaCase("+image+")");}} //32
TOKEN : { <Case: "case" > {System.out.println("Case");}}// cambio hay que ver donde poner el switch
TOKEN : { <Switch: "switch" > {System.out.println("Switch");}}// No pude hacer el case como lo planee
TOKEN : { <CasoDefatult: "default">{System.out.println("Default");}}
TOKEN : { <ComprobacionDeDesbordamiento: "check "|"unchecked" >{System.out.println("ComprobacionDeDesbordamiento("+image+")");}} //34
TOKEN : {<DeclaracionDeClase: "clase" >{System.out.println("DeclaracionDeClase");}} //35
TOKEN : {<ModificadorDeTipo: "const"|"signed"|"unsigned" >{System.out.println("ModificadorDeTipo("+image+")");}} //36
TOKEN : {<DeclaracionEnumeracion: "enum">{System.out.println("DeclaracionEnumeracion");}} //37
TOKEN : {<DeclaracionDeEvento: "event">{System.out.println("DeclaracionDeEvento");}} //38
TOKEN : {<OperacionesDeConversion: "explicit"|"implicit"|"operator">{System.out.println("OperacionesDeConversion("+image+")");}} // 39
TOKEN : {<ValorBooleano: "true"|"false">{System.out.println("ValorBooleano("+image+")");}} // 40
TOKEN : {<Ciclos: "do"|" while"|"for"|"foreach">{System.out.println("Ciclo("+image+")");}} // 41
TOKEN : {<ModificadorDeParametro: "in"|"out"|"params"|"ref" >{System.out.println("ModificadorDeParametro("+image+")");}} // 42
TOKEN : {<ProductorDeGeneradores: "yield">{System.out.println("ProductorDeGeneradores");}} // 43
TOKEN : {<Using: "using">{System.out.println("SentenciaUsing");}} // 44
TOKEN : {<EspacioDeNombre: "namespace">{System.out.println("EspacioDeNombre");}} // 45
TOKEN : {<ModificadorDeclaracionMiembro: "new"|"transient">{System.out.println("ModificadorDeclaracionMiembro("+image+")");}} // 46
TOKEN : {<ValorNulo: "null">{System.out.println("ValorNulo");}} // 47
TOKEN : {<ModificadorDeMetodo: "override">{System.out.println("ModificadorDeMetodo");}} // 48
TOKEN : {<ModificadorDeAcceso: "public"|"private"|"protected"|"friend" >{System.out.println("ModificadorDeAcceso("+image+")");}} // 49
TOKEN : {<TamanoDeTipo: "sizeof">{System.out.println("TamanoDeTipo");}} // 52
TOKEN: { <Estructura: "struct">{System.out.println("Estructura");}}
TOKEN: { <Extends:"extends">{System.out.println("extends");}}
TOKEN: { <Package:"package">{System.out.println("Package");}}
TOKEN: { <Global:"global">{System.out.println("Global");}}
TOKEN: { <Join:"join">{System.out.println("Join");}}
TOKEN: { <Lock:"lock">{System.out.println("Lock");}}
TOKEN: { <Dllexport:"dllexport" >{System.out.println("Dllexport");}}
TOKEN: { <Dllimport: "dllimport" >{System.out.println("Dllimport");}}
TOKEN: { <Extern: "extern">{System.out.println("extern");}}
TOKEN: { <Noreturn:"noreturn">{System.out.println("noreturn");}}
TOKEN: { <Def:"def">{System.out.println("Def");}}
TOKEN: { <Del: "del">{System.out.println("Del");}}
TOKEN: { <None: "none">{System.out.println("None");}}
TOKEN: { <Elif: "elif">{System.out.println("Elif");}}
TOKEN: { <Nolocal: "nonlocal">{System.out.println("Nonlocal");}}
TOKEN: { <Equals: "equals">{System.out.println("Equals");}}
TOKEN: { <OperadorDeConversion: "reinterpret_cast" | "dynamic_cast">{System.out.println("OperadorDeConversion ( "+image+") ");}}
TOKEN: { <Delete: "delete">{System.out.println("Delete");}}
TOKEN: { <Object: "object">{System.out.println("Object");}}
TOKEN: { <Super: "super">{System.out.println("Super");}}
TOKEN: { <Import: "import">{System.out.println("Import");}}
TOKEN: { <Strictfp: "strictfp">{System.out.println("Strictfp");}}
TOKEN: { <Var: "var">{System.out.println("Var");}}
TOKEN: { <DescriptoresDeAcceso: "get" | "set">{System.out.println("DescriptoresDeAcceso ( "+image+") ");}}
TOKEN: { <Pass: "pass">{System.out.println("Pass");}}
TOKEN: { <Typeid: "typeid">{System.out.println("Typeid");}}
TOKEN: { <Typedef:"typedef">{System.out.println("Typedef");}}
TOKEN: { <Volatile: "volatile">{System.out.println("Volatile");}}
TOKEN: { <Print:"print">{System.out.println("Print");}}
TOKEN: { <Implements: "implements">{System.out.println("Implements");}}
TOKEN: { <Fixed: "fixed">{System.out.println("Fixed");}}
TOKEN: { <Instanceof: "instanceof">{System.out.println("Instanceof");}}
TOKEN: { <EspecificadorDeAlmacenamiento: "register" | "mutable" |"static">{System.out.println("EspecificadorDeAlmacenamiento ("+image+") ");}}
TOKEN : { < ModificadorAbstract : "abstract" >{System.out.println("ModificadorAbstract");}}
TOKEN : { < DeclaracionClaseSellada : "sealed" >{System.out.println("sealed");}}
TOKEN : { < ModificadorSoloLectura : "readonly" >{System.out.println("readonly");}}
TOKEN : { < ManejoDeExcepciones : "try"|"catch"|"finally"|"throw"|"throws" >{System.out.println("ManejoDeExcepciones ("+image+")");}} 
TOKEN : { < DeclaracionTry : "try" > {System.out.println("Declaracion Try");
TOKEN : { < DeclaracionCatch : "catch" > {System.out.println("Declaracion Catch");
/*Identificador*/
TOKEN: {<Main: "main">{System.out.println("Main");}}
TOKEN : { < Id : (<WORD>)+(<NUMBER>|<NUMBER>|<SPECIAL>)* >}

void Start(PrintStream printStream) throws NumberFormatException:
{
	Token t;
	ArrayList<String> tabla;
	tabla = new ArrayList<String>();
}
{
	/*
	(t = <Id> {
		String palabra = t.image;
		int i = 0;
		for (; i < tabla.size(); i++)
		{
			if(palabra.equals(tabla.get(i)))
			{
				break;
			}
		}
		if(tabla.size() == i){
			tabla.add(palabra);
		}
		System.out.println("Identificador ("+Integer.toString(i)+")");
	}
	/*
	|<NUMBER> |  <Asignacion> | <OperadorAritmeticoBinario> | <Coma> | <Rango> 
	| <DirectivasDePreprocesador> | <OperadoresLogicos> | <FuncionMatematica> 
	| <OperadorRelacional> | <Parentesis> | <Corchete> | <Comentario> 
	| <OperadorAritmetico> | <Llaves> | <ReferenciasPunteros> | <SentenciaIF> 
	| <FuncionesPredefinidasFuncionales> | <FuncionesPredefinidasIterativas> 
	| <ReferenciaApuntador> | <TipoDeDato> | <AccesoAElementos> | <FinDeLinea> 
	| <ValorNulo> | <ModificadorDeclaracionMiembro> | <EspacioDeNombre> 
	| <SentenciaUsing> | <ProductorDeGeneradores> | <ModificadorDeParametro> 
	| <Ciclos> | <ValorBooleano> | <OperacionesDeConversion> 
	| <DeclaracionDeEvento>	| <DeclaracionEnumeracion> | <ModificadorDeTipo> 
	| <DeclaracionDeClase> | <ComprobacionDeDesbordamiento> 
	| <ComponentesSentenciaCase> | <InterrupcionDeProcesos> 
	| <ExpresionDeConversion> | <ExpresionWhere> | <DeclaracionDeTipos> 
	| <ClasesPredefinidas> | <PartesExpresionLet> | <OfExpresionCase> 
	| <Return>| <Comillas> | <Estructura> | <Extends> | <Package> | <Global> 
	| <Join>| <Lock>| <Noreturn> | <Def> | <Del> 
	| <None> | <Elif> | <Nolocal> | <Equals> | <OperadorDeConversion> | <Delete> | <Object>
	| <EspecificadorDeAlmacenamiento> | <Super> | <Import> | <Strictfp> | <Var>
	| <DescriptoresDeAcceso> | <Pass> | <Typeid> | <Typedef> | <Volatile> | <Print>
	| <Implements> | <Fixed> | <Instanceof> | <TamanoDeTipo> | <ModificadorSoloLectura>| <ManejoDeExcepciones>
	| <ModificadorDeMetodo>| <ModificadorDeAcceso> | <DeclaracionClaseSellada> | <Dllexport>
	| <Dllimport> | <Extern> | <ModificadorAbstract>| <Main>)*
          */
	Programa()
	<EOF>
}

// Gramatica
void Programa():
{}
{
	( Librerias() )* ( Clase() | Funcion() | DeclaracionEstructura )* FuncionMain()
}
void Librerias():
{
	<DirectivasDePreprocesador> <Id> <AccesoAElementos> <Id>
}

void Clase():
{}
{
	<DeclaracionDeClase> <Id> <Rango> (BloqueModificadorAcceso() | Constructor())+ <FinDeLinea>
}
void BloqueModificadorAcceso():
{
	<ModificadorDeAcceso> <Llaves> ( FuncionODeclaracion() | Metodo() )+ <Llaves>
}
void FuncionODeclaracion():
{}
{
	<TipoDeDato> ( <ModificadorDeAcceso> <Id> | <Id> ( FuncionSinNombreNiTipo() )? ) <FinDeLinea>
}
void FuncionSinNombreNiTipo():
{}
{
	Parametros() <Rango> ( Sentencia() )* ExpresionReturn() 
}
void Constructor():
{
	Encabezado() <Rango> ( Sentencia() )* <FinDeLinea>
}
void DeclaracionEstructura():
{}
{
	<Estructura> <Id> <Rango> ( DeclaracionVariable() )+ <FinDeLinea>
}
void InstanciaObjeto():
{}
{
	ModificadorDeclaracionMiembro (<Id> | <ClasesPredefinidas>) ( IngresarParametros())
}
// Funciones
void Encabezado():
{}
{
	<Id> Parametros()
}

void IngresarParametros():
{}
{
	((<Id> ( AccesoAElementoArreglo | InvocacionFuncion())? <Coma> )* <Id> (AccesoAElementoArreglo() | InvocacionFuncion())? )?
}
void Parametros():
{}
{
	( ( VariableParametro() <Coma> )* VariableParametro() )?
}

void VariableParametro():
{}
{
	( <ReferenciasPunteros> )? DeclaracionVariable()
}

void DeclaracionVariable():
{}
{
	<TipoDeDato> ( <ModificadorDeTipo> )? <Id> <FinDeLinea>
}

void Sentencia():
{}
{
	( DeclaracionVariable() | SentenciaAsignacion() | Ciclo() | Condicional() | Metodo() | SalidaEnPantalla() | DeclaracionArreglo()) <FinDeLinea>
}

void Metodo():
{}
{
	Encabezado() <Rango> (Sentencia())* <FinDeLinea>
}

void InvocarMetodo():
{}
{
	<Id> InvocacionFuncion()
}

void Funcion():
{}
{
	<TipoDeDato> Encabezado() <Rango> (Sentencia())* ExpresionReturn() <FinDeLinea>
}
void FuncionMain():
{}
{
	<Main> <Rango> Sentencia()* <FinDeLinea>
}
void InvocacionFuncion():
{}
{
	<Parentesis> IngresarParametros() <Parentesis>
}

//Cadenas//
void CadenaString():
{}
{
	<Comillas>.<Comillas>
}

//Expresiones// 
void ExpresionReturn():
{}
{
	<Return> ExpresionGeneral()
}
void ExpresionGeneral():
{}
{
	(<Parentesis> ExpresionGeneral() <Parentesis>
	|<ValorBooleano> ParteDerExpBooleana()
	|<Id> FuncionOArreglo()(ParteDerExpBooleana() |ParteDerExpAritmeticaOString() |ParteDerComparacion() )? 
	|<Number> (ParteDerExpAritmetica()| ParteDerComparacion() )?
	|CadenaString() (ParteDerExpString()) ?)
}
void ExpresionAritmetica():
{}
{
	(<Parentesis> ExpresionAritmetica() <Parentesis> 
	|(<Id> FuncionOArreglo()| <Number>) ParteDerExpAritmetica?)
}
void ExpresionBooleana():
{}
{
	(<Parentesis> ExpresionBooleana() <Parentesis> 
	|<Id> FuncionOArreglo()(ParteDerExpBooleana() | ParteDerComparacion() )?
	|<ValorBooleano> (ParteDerExpBooleana())? )
}
void ExpresionString():
{}
{
	(<Parentesis> ExpresionString() <Parentesis> 
	|<Id> FuncionOArreglo() (ParteDerExpString())?
	|CadenaString() (ParteDerExpString())? )
}
void ParteDerExpAritmetica():
{}
{
	<OperadorAritmeticoBinario> ExpresionAritmetica()
}
void ParteDerExpBooleana():
{}
{
	<OperadoresLogicos> ExpresionBooleana()
}
void ParteDerComparacion():
{}
{
	<OperadorRelacional> ExpresionAritmetica()
}
void ParteDerExpString():
{}
{
	<OperadorAritmeticoBinario> ExpresionString()
}
void ParteDerExpAritmeticaOString():
{}
{
	<OperadorAritmeticoBinario> ( <Parentesis> ( ExpresionString() | ExpresionAritmetica() ) <Parentesis> | <Id> FuncionOArreglo() ( ParteDerExpString() | ParteDerExpAritmetica() )? | CadenaString() ( ParteDerExpString() )? | <Number> ( ParteDerExpAritmetica())? )
}

void FuncionOArreglo():
{}
{
	(AccesoAElementoArreglo() | InvocacionFuncion())?
}

void SentenciaAsignacion():
{}
{
	ExpresionGeneral() <OperadorRelacional> <Id> <FinDeLinea>
}

void SentenciaAritmeticaUnaria():
{}
{
	<Id> <OperacionAritmeticaUnaria>
}

void DelcaracionVariableGlobal():
{}
{
	<Global> <Id> (<Rango> ExpresionAritmetica() <Rango> ) ? <FinDeLinea>
}
//Ciclos//
void Ciclo():
{}
{
	<Ciclos> ( CicloWhile() | CicloFor() | CicloForeach() | CicloWhile() )
}

void CicloFor():
{}
{
	<for> RangoNumerico() <Rango> (Sentencia()+) <FinDeLinea>  
}

void RangoNumerico():
{}
{
	<Corchete> <Number> <Rango> <Number> <Corchete>
}
void CicloForeach():
{}
{
	<TipoDeDato> <Id> <Of> <Id> <Rango> (Sentencia())+ <FinDeLinea>
}

void CicloWhile():
{}
{
	ExpresionBooleana() <Rango> (Sentencia())+ <FinDeLinea>
}

void CicloDoWhile():
{}
{
	<Llaves> ExpresionBooleana <Llaves> <Rango> (Sentencia())+ <FinDeLinea>
}

//Condicionales//
void Condicional()
{}
{
	(CondicionIf()| CondicionCase())
}
:
void CondicionIf()
{}
{
	<SentenciaIF> ExpresionBooleana() <Rango> (Sentencia())+ <FinDeLinea> (<Elif> ExpresionBooleana() (Sentencia())+ <FinDeLinea>)* (<SentenciaIF> (Sentencia())+ <FinDeLinea>)?
}

void CondicionCase()
{}
{
	<Switch> <Id> <Rango> (<Case> <Id> <Rango> (Sentencia())+ <Break>)* (<Case> <CasoDefault> <Rango> (Sentencia())+ <Break> )? <FinDeLinea>
}

void SalidaEnPantalla()
{}
{
	<Print> ExpresionGeneral() <FinDeLinea>
}

void ReferenciaSuperclase()
{}
{
	<DeclaracionDeClase> <Id> <Extends> <Id> <Rango>
}

void ReferenciaSuperclaseAtributo()
{}
{
	<Super> <AccesoAElementos> <Id>
}

// Control de excepciones

void DeclaracionTryCatch():
{}
{
	SentenciaTry() SentenciaCatch()
}

void SentenciaTry():
{}
{
	<SentenciaTry> <Rango> (Sentencia())+ <FinDeLinea> 
}

void SentenciaCatch():
{}
{
	<DeclaracionCatch> <Rango> (Sentencia())* <FinDeLinea>
}

//Arreglos
void DeclaracionArreglo():
{}
{
	SentenciaCorchetes() <Asignacion> <TipoDeDato> <Id> <FinDeLinea>
}

void SentenciaCorchetes():
{}
{
	(<Corchete> <Corchete>)+
}

void AccesoAElementoArreglo():
{}
{
	(<Corchete> ExpresionAritmetica() <Corchete>)+
}

void InicializacionArreglo():
{}
{
	Arreglo() <Asignacion> <Id>
}

void Arreglo():
{}
{
	<Llaves> (Vector() <Rango>)* Vector() <Llaves>
}

void Vector():
{}
{
	(ElementosDeArreglo() <Coma>)* ElementosDeArreglo()
}

void ElementosDeArreglo():
{}
{
	(<Id> | Arreglo() | <Number> | CadenaString())
}

//Programacion Funcional
void ExpresionFuncional():
{}
{
	<Def> <Id> ( <Id> )* <Asignacion> CuerpoExpresionFuncional() <FinDeLinea>
}

void CuerpoExpresionFuncional():
{}
{
	(Lista()| (<Id>)* ( <Llaves> (( <Id> <Coma>)* <Id> )?<Llaves>)? (ParteDerExpFun())? | <FuncionesPredefinidasFuncionales> <Llaves> ExpresionFuncional() <Llaves> (ParteDerExpFun())? )
}

void ParteDerExpFun():
{}
{
	<OperadorAritmeticoBinario> ExpresionFuncional()
}

void Lista():
{}
{
	<Llaves> ExpresionAritmetica() <Rango> ExpresionAritmetica() <Llaves>
}

//Expresion let in

void ExpresionLetIn():
{
	<Let> ( <TipoDeDato> )? <Id> ( <Asignacion> ExpresionGeneral() )? ( <In> DefinicionLetIn )? <FinDeLinea>
}

void DefinicionLetIn():
{}
{
	( ( <Id> <Asignacion>)? ExpresionGeneral())+
}

// Enumeracion

void Enumeracion():
{}
{
	<DeclaracionEnumeracion> <Id> <Rango> ( <Id> <Coma> )+ <Id> <FinDeLinea>
}

void AccesoEnumeracion():
{}
{
	<Id> <AccesoAElementos> <Id>
}

//Comentarios

void ComentarioMultilinea():
{}
{
	<Comentario> . <Comentario>
}

//Namespace

void SentenciaNamespace():
{}
{
	<EspacioDeNombre> <Id> <Rango> ( Sentencia() )+ <FinDeLinea>
}

void ReferenciaNamespace():
{}
{
	<EspacioDeNombre> <Rango> <Rango> <Id> ( <Parentesis> <Parentesis> | <Rango> (Sentencia())+ ) <FinDeLinea>
}

void SentenciaUsing ():
{}
{
	<Using> <EspacioDeNombre> <Id>
}

//Importacion y Exportacion de Dllexport
void ExportarDLL():
{}
{
	<DirectivasDePreprocesador> <Id> <Parentesis> <Dllexport> <Rango> (Sentencia()+) <FinDeLinea>
}

void ImportarDLL():
{}
{
	<dllimport> <Llaves> <Id> <Llaves> <FinDeLinea>
}

//Otras
void ObtenerTamanoDeTipo():
{}
{
	<TamanoDeTipo> <TipoDeDato>
}
void RenombreDeTipo():
{}
{
	<DeclaracionDeTipos> <TipoDeDato> <Rango> <Id>
}
void Conversion():
{}
{
	<Id> <ExpresionDeConversion> <TipoDeDato>
}
void ComprobacionDeTipoOClase():
{}
{
	<Id> <Instanceof> (<Id> | <Struct> | <TipoDeDato>)
}
void VariableNoLocal():
{}
{
	<Nolocal> <Id>
}
void Lectura():
{}
{
	<Read> <Id>
}

